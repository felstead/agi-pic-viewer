// From https://github.com/jrmuizel/raqote-examples/blob/master/examples/minifb.rs
use minifb::{MouseMode, Window, WindowOptions, ScaleMode, Scale};
use raqote::*;
use font_kit::family_name::FamilyName;
use font_kit::properties::Properties;
use font_kit::source::SystemSource;

use std::time::{Duration, Instant};

const WIDTH: usize = 320;
const HEIGHT: usize = 200;
const TOOLBAR_SIZE: usize = 100;
const PIXEL_SIZE: usize = 3; 

pub fn render_window() {

    let width = WIDTH * PIXEL_SIZE;
    let height = HEIGHT * PIXEL_SIZE + TOOLBAR_SIZE;

    let mut window = Window::new("AGI", width, height, WindowOptions { ..WindowOptions::default() }).unwrap();
    
    let font = SystemSource::new()
        .select_best_match(&[FamilyName::SansSerif], &Properties::new())
        .unwrap()
        .load()
        .unwrap();
    let size = window.get_size();
    let mut dt = DrawTarget::new(size.0 as i32, size.1 as i32);

    dt.clear(SolidSource::from_unpremultiplied_argb(0xff, 0xff, 0xff, 0xff));

    // Draw the borders for our pixels
    let grid_source = Source::Solid(SolidSource { r: 0x0, g: 0x0, b: 0x0, a: 0x40 });
    let grid_style = StrokeStyle { width: 1., ..Default::default() };
    let grid_options = DrawOptions { antialias: AntialiasMode::None, ..Default::default() };
    for x in 0..WIDTH / 2 {
        // Vertical lines
        let mut pb = PathBuilder::new();
        pb.move_to(x as f32 * PIXEL_SIZE as f32 * 2.0, 0.);
        pb.line_to(x as f32 * PIXEL_SIZE as f32 * 2.0, HEIGHT as f32 * PIXEL_SIZE as f32);
        let path = pb.finish();

        dt.stroke(&path, &grid_source, &grid_style, &grid_options);
    }

    for y in (0..HEIGHT) {
        let mut pb = PathBuilder::new();
        pb.move_to(0., y as f32 * PIXEL_SIZE as f32);
        pb.line_to(WIDTH as f32 * PIXEL_SIZE as f32, y as f32 * PIXEL_SIZE as f32);
        let path = pb.finish();

        dt.stroke(&path, &grid_source, &grid_style, &grid_options);
    }

    // Limit to max ~60 fps update rate
    window.limit_update_rate(Some(std::time::Duration::from_micros(16600)));

    let mut fps = 0.;
    while window.is_open() {
        let now = Instant::now();

        // Toolbar, redraw this every frame
        {
            let mut pb = PathBuilder::new();
            pb.rect(0., (PIXEL_SIZE * HEIGHT) as f32, (PIXEL_SIZE * WIDTH) as f32, TOOLBAR_SIZE as f32);
            let path = pb.finish();
            dt.fill(&path, &Source::Solid(SolidSource::from_unpremultiplied_argb(0xff, 0xdf, 0xdf, 0xdf)), &DrawOptions::new());
        }

        if let Some(pos) = window.get_mouse_pos(MouseMode::Clamp) {
            let transformed_pos = ( (pos.0 / PIXEL_SIZE as f32 / 2.0).floor(), (pos.1 / PIXEL_SIZE as f32).floor());

            if transformed_pos.0 < WIDTH as f32 && transformed_pos.1 < HEIGHT as f32 {
                let pos_string = format!("{},{}", transformed_pos.0, transformed_pos.1);

                dt.draw_text(&font, 18., &pos_string, Point::new(10., (HEIGHT * PIXEL_SIZE) as f32 + (TOOLBAR_SIZE / 2) as f32),
                    &Source::Solid(SolidSource::from_unpremultiplied_argb(0xff, 0, 0, 0)),
                    &DrawOptions::new(),
               );
            }
        }

        if fps > 0. {
            dt.draw_text(&font, 18., &format!("{:.1} fps", fps), Point::new(width as f32 - 100., (HEIGHT * PIXEL_SIZE) as f32 + (TOOLBAR_SIZE / 2) as f32),
            &Source::Solid(SolidSource::from_unpremultiplied_argb(0xff, 0, 0, 0)),
            &DrawOptions::new(),);
        }

        window.update_with_buffer(&dt.get_data(), size.0, size.1).unwrap();


        let frame_time = now.elapsed().as_secs_f64();
        fps = 1. / frame_time as f64;
    }
}